{"ast":null,"code":"const BASE_URL = 'https://mate.academy/students-api';\n\n// a promise resolved after a given delay\nfunction wait(delay) {\n  return new Promise(resolve => {\n    setTimeout(resolve, delay);\n  });\n}\n\n// To have autocompletion and avoid mistypes\n\nfunction request(url) {\n  let method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'GET';\n  let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  const options = {\n    method\n  };\n  if (data) {\n    // We add body and Content-Type only for the requests with data\n    options.body = JSON.stringify(data);\n    options.headers = {\n      'Content-Type': 'application/json; charset=UTF-8'\n    };\n  }\n\n  // we wait for testing purpose to see loaders\n  return wait(300).then(() => fetch(BASE_URL + url, options)).then(response => {\n    if (!response.ok) {\n      throw new Error();\n    }\n    return response.json();\n  });\n}\nexport const client = {\n  get: url => request(url),\n  post: (url, data) => request(url, 'POST', data),\n  patch: (url, data) => request(url, 'PATCH', data),\n  delete: url => request(url, 'DELETE')\n};","map":{"version":3,"names":["BASE_URL","wait","delay","Promise","resolve","setTimeout","request","url","method","data","options","body","JSON","stringify","headers","then","fetch","response","ok","Error","json","client","get","post","patch","delete"],"sources":["D:/projects/react_todo-app-with-api/src/utils/fetchClient.ts"],"sourcesContent":["const BASE_URL = 'https://mate.academy/students-api';\n\n// a promise resolved after a given delay\nfunction wait(delay: number) {\n  return new Promise(resolve => {\n    setTimeout(resolve, delay);\n  });\n}\n\n// To have autocompletion and avoid mistypes\ntype RequestMethod = 'GET' | 'POST' | 'PATCH' | 'DELETE';\n\nfunction request<T>(\n  url: string,\n  method: RequestMethod = 'GET',\n  data: any = null, // we can send any data to the server\n): Promise<T> {\n  const options: RequestInit = { method };\n\n  if (data) {\n    // We add body and Content-Type only for the requests with data\n    options.body = JSON.stringify(data);\n    options.headers = {\n      'Content-Type': 'application/json; charset=UTF-8',\n    };\n  }\n\n  // we wait for testing purpose to see loaders\n  return wait(300)\n    .then(() => fetch(BASE_URL + url, options))\n    .then(response => {\n      if (!response.ok) {\n        throw new Error();\n      }\n\n      return response.json();\n    });\n}\n\nexport const client = {\n  get: <T>(url: string) => request<T>(url),\n  post: <T>(url: string, data: any) => request<T>(url, 'POST', data),\n  patch: <T>(url: string, data: any) => request<T>(url, 'PATCH', data),\n  delete: (url: string) => request(url, 'DELETE'),\n};\n"],"mappings":"AAAA,MAAMA,QAAQ,GAAG,mCAAmC;;AAEpD;AACA,SAASC,IAAI,CAACC,KAAa,EAAE;EAC3B,OAAO,IAAIC,OAAO,CAACC,OAAO,IAAI;IAC5BC,UAAU,CAACD,OAAO,EAAEF,KAAK,CAAC;EAC5B,CAAC,CAAC;AACJ;;AAEA;;AAGA,SAASI,OAAO,CACdC,GAAW,EAGC;EAAA,IAFZC,MAAqB,uEAAG,KAAK;EAAA,IAC7BC,IAAS,uEAAG,IAAI;EAEhB,MAAMC,OAAoB,GAAG;IAAEF;EAAO,CAAC;EAEvC,IAAIC,IAAI,EAAE;IACR;IACAC,OAAO,CAACC,IAAI,GAAGC,IAAI,CAACC,SAAS,CAACJ,IAAI,CAAC;IACnCC,OAAO,CAACI,OAAO,GAAG;MAChB,cAAc,EAAE;IAClB,CAAC;EACH;;EAEA;EACA,OAAOb,IAAI,CAAC,GAAG,CAAC,CACbc,IAAI,CAAC,MAAMC,KAAK,CAAChB,QAAQ,GAAGO,GAAG,EAAEG,OAAO,CAAC,CAAC,CAC1CK,IAAI,CAACE,QAAQ,IAAI;IAChB,IAAI,CAACA,QAAQ,CAACC,EAAE,EAAE;MAChB,MAAM,IAAIC,KAAK,EAAE;IACnB;IAEA,OAAOF,QAAQ,CAACG,IAAI,EAAE;EACxB,CAAC,CAAC;AACN;AAEA,OAAO,MAAMC,MAAM,GAAG;EACpBC,GAAG,EAAMf,GAAW,IAAKD,OAAO,CAAIC,GAAG,CAAC;EACxCgB,IAAI,EAAE,CAAIhB,GAAW,EAAEE,IAAS,KAAKH,OAAO,CAAIC,GAAG,EAAE,MAAM,EAAEE,IAAI,CAAC;EAClEe,KAAK,EAAE,CAAIjB,GAAW,EAAEE,IAAS,KAAKH,OAAO,CAAIC,GAAG,EAAE,OAAO,EAAEE,IAAI,CAAC;EACpEgB,MAAM,EAAGlB,GAAW,IAAKD,OAAO,CAACC,GAAG,EAAE,QAAQ;AAChD,CAAC"},"metadata":{},"sourceType":"module"}